# Generic Generator by Joeri Exelmans
#
# Visits SCCD-domain constructs (see sccd_constructs.py) and converts them
# to a generic language AST (see generic_language_constructs.py), that can
# then be visited by a target language writer.

# import traceback
# import time
# import os
import itertools
from sccd.compiler.utils import Enum, Logger
from sccd.compiler.visitor import Visitor
from sccd.compiler.sccd_constructs import FormalParameter
from sccd.compiler.stateful_writer import StatefulWriter
import python_sccd.python_sccd_compiler.generic_language_constructs as GLC
import sccd.compiler.generic_language_constructs as GLC
import xml.etree.ElementTree as ET

Platforms = Enum("Threads","GameLoop","EventLoop") 

class GenericGenerator(Visitor):
    
    def __init__(self, platform, debug_mode):
        self.platform = platform
        self.debug_mode = debug_mode # == 1
        self.writer = StatefulWriter()
        self.attributes = []
        self.breakpoints = self.setBreakpoints() if debug_mode == 1 else []
        self.numberOfAfterEvents = 0
        # path = os.path.realpath(__file__) 
        # print(path)
        # dir = os.path.dirname(path)     
        # dir = dir.replace('python_sccd_compiler', 'imports')
        # os.chdir(dir)
        # print(dir)

    def generic_visit(self, node):
        Logger.showWarning("GenericGenerator has no visit method for node of type '" + str(type(node)) + "'.")

    def get(self):
        return self.writer.get()
    
    def setBreakpoints(self):
        f = open("breakpoints.xml", "r")
        breakpointList = ET.parse(f).getroot()
        breakpoints = {}
        breakpoints['states'] = {}
        breakpoints['timestamps'] = []
        breakpoints['variables'] = {}
        iteration = 0
        for b in breakpointList.findall('breakpoint'):
            if b.get('state') != None:
                breakpoints['states'][b.get('state')] = iteration
            elif b.get('timestamp') != None:
                breakpoints["timestamps"].append(b.get('timestamp'))
            elif b.get('variable') != None and b.get('value') != None:
                breakpoints["variables"][b.get('variable')] = b.get('value')
            iteration = iteration + 1
            
        return breakpoints

    def visit_ClassDiagram(self, class_diagram):
        header = ("Generated by Statechart compiler by Glenn De Jonghe, Joeri Exelmans, Simon Van Mierlo, and Yentl Van Tendeloo (for the inspiration)\n")
        if class_diagram.name or class_diagram.author or class_diagram.description:
            header += "\n"
        if class_diagram.author:
            header += "Model author: " + class_diagram.author + "\n"
        if class_diagram.name:
            header += "Model name:   " + class_diagram.name + "\n"
        if class_diagram.description.strip():
            header += "Model description:\n"
            header += class_diagram.description.strip()

        self.writer.addMultiLineComment(header)
        self.writer.addVSpace()
        #self.writer.addInclude(([GLC.RuntimeModuleIdentifier(), "statecharts_core"]))
        self.writer.addInclude((["python_sccd.python_sccd_runtime.statecharts_core"]))
        self.writer.addInclude((["sccd.runtime.statecharts_core"]))
        self.writer.addInclude((["python_sccd.python_sccd_runtime.colors"]))

        #self.writer.addInclude((["sccd.compiler.utils"]))
        self.writer.addRawCode("import argparse")
        self.writer.addRawCode("from sccd.compiler.utils import FileWriter")
        self.writer.addRawCode("import os")
        self.writer.addRawCode("import inspect")
        
       # self.writer.addRawCode("from colors import *")

        #from python_sccd.python_sccd_runtime.statecharts_core import *
        if class_diagram.top.strip():
            self.writer.addRawCode(class_diagram.top)
        self.writer.addVSpace()

        self.writer.beginPackage(class_diagram.name)
        
        # visit children
        for c in class_diagram.classes :
            c.accept(self)
         
        self.writer.beginClass("ObjectManager", ["ObjectManagerBase"])

        self.writer.beginConstructor()
        self.writer.addFormalParameter("controller")
        self.writer.beginMethodBody()
        self.writer.beginSuperClassConstructorCall("ObjectManagerBase")
        self.writer.addActualParameter("controller")
        self.writer.endSuperClassConstructorCall()
        self.writer.endMethodBody()
        self.writer.endConstructor()

        self.writer.beginMethod("instantiate")
        self.writer.addFormalParameter("class_name")
        self.writer.addFormalParameter("construct_params")
        self.writer.beginMethodBody()
        for index,c in enumerate(class_diagram.classes):
            self.writer.beginElseIf(GLC.EqualsExpression("class_name", GLC.String(c.name)))
            if c.isAbstract():
                # cannot instantiate abstract class
                self.writer.add(GLC.ThrowExceptionStatement(GLC.String("Cannot instantiate abstract class \"" + c.name + "\" with unimplemented methods \"" + "\", \"".join(c.abstract_method_names) + "\".")))
            else:
                new_expr = GLC.NewExpression(c.name, [GLC.SelfProperty("controller")])
                param_count = 0
                for p in c.constructors[0].parameters:
                    new_expr.getActualParameters().add(GLC.ArrayIndexedExpression("construct_params", str(param_count)))
                    param_count += 1
                self.writer.addAssignment(
                    GLC.LocalVariableDeclaration("instance"),
                    new_expr)
                self.writer.addAssignment(
                    GLC.Property("instance", "associations"),
                    GLC.MapExpression())
                for a in c.associations:
                    a.accept(self)
            self.writer.endElseIf()
        self.writer.beginElse()
        self.writer.add(
            GLC.ThrowExceptionStatement(
                GLC.AdditionExpression(
                    GLC.String("Cannot instantiate class "),
                    "class_name"
                )
            )
        )
        self.writer.endElse()
        self.writer.add(GLC.ReturnStatement("instance"))
        self.writer.endMethodBody()
        self.writer.endMethod()
        self.writer.endClass() # ObjectManager

        if self.platform == Platforms.Threads:
            controller_sub_class = "ThreadsControllerBase"
        if self.platform == Platforms.EventLoop :
            controller_sub_class = "EventLoopControllerBase"
        elif self.platform == Platforms.GameLoop :
            controller_sub_class = "GameLoopControllerBase"

        self.writer.beginClass("Controller", [controller_sub_class])
        self.writer.beginConstructor()
        for p in class_diagram.default_class.constructors[0].parameters:
            p.accept(self)
        if self.platform == Platforms.EventLoop:
            self.writer.addFormalParameter("event_loop_callbacks")
            self.writer.addFormalParameter("finished_callback", GLC.NoneExpression())
            self.writer.addFormalParameter("behind_schedule_callback", GLC.NoneExpression())
        elif self.platform == Platforms.Threads:
            self.writer.addFormalParameter("keep_running", GLC.TrueExpression())
            self.writer.addFormalParameter("behind_schedule_callback", GLC.NoneExpression())
        self.writer.beginMethodBody()
        self.writer.beginSuperClassConstructorCall(controller_sub_class)
        self.writer.addActualParameter(GLC.NewExpression("ObjectManager", [GLC.SelfExpression()]))
        if self.platform == Platforms.EventLoop:
            self.writer.addActualParameter("event_loop_callbacks")
            self.writer.addActualParameter("finished_callback")
            self.writer.addActualParameter("behind_schedule_callback")
        elif self.platform == Platforms.Threads:
            self.writer.addActualParameter("keep_running")
            self.writer.addActualParameter("behind_schedule_callback")
        self.writer.endSuperClassConstructorCall()
        for i in class_diagram.inports:
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addInputPort"), [GLC.String(i)]))
        for o in class_diagram.outports:
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addOutputPort"), [GLC.String(o)]))
        actual_parameters = [p.getIdent() for p in class_diagram.default_class.constructors[0].parameters]
        self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("object_manager"), "createInstance"), [GLC.String(class_diagram.default_class.name), GLC.ArrayExpression(actual_parameters)]))
        self.writer.endMethodBody()
        self.writer.endConstructor()
        self.writer.endClass() # Controller
        
        # visit test node if there is one
        if class_diagram.test:
            class_diagram.test.accept(self)

        self.writer.endPackage()

    ### TESTS
    def visit_DiagramTest(self, test):
        # helper class
        self.writer.beginClass("InputEvent")
        self.writer.beginConstructor()
        self.writer.addFormalParameter("name")
        self.writer.addFormalParameter("port")
        self.writer.addFormalParameter("parameters")
        self.writer.addFormalParameter("time_offset")
        self.writer.beginMethodBody()
        self.writer.addAssignment(GLC.SelfProperty("name"), "name")
        self.writer.addAssignment(GLC.SelfProperty("port"), "port")
        self.writer.addAssignment(GLC.SelfProperty("parameters"), "parameters")
        self.writer.addAssignment(GLC.SelfProperty("time_offset"), "time_offset")
        self.writer.endMethodBody()
        self.writer.endConstructor()
        self.writer.endClass()
        self.writer.beginClass("Test")
        if test.input:
            test.input.accept(self)
        else:
            self.writer.addStaticAttribute("input_events", GLC.ArrayExpression())
        if test.expected:
            test.expected.accept(self)
        else:
            self.writer.addStaticAttribute("expected_events", GLC.ArrayExpression())
        self.writer.endClass()

    def visit_DiagramTestInput(self, test_input):
        # write array of input events
        self.writer.startRecordingExpression()
        self.writer.beginArray()
        for e in test_input.input_events:
            e.accept(self)
        self.writer.endArray()
        array_expr = self.writer.stopRecordingExpression()
        self.writer.addStaticAttribute("input_events", array_expr)

    def visit_DiagramTestInputEvent(self, event):
        self.writer.add(GLC.NewExpression("InputEvent", [GLC.String(event.name), GLC.String(event.port), GLC.ArrayExpression(event.parameters), event.time]))

    def visit_DiagramTestExpected(self, test_expected):
        # write array of slots containing expected events
        self.writer.startRecordingExpression()
        self.writer.beginArray()
        for s in test_expected.slots:
            s.accept(self)
        self.writer.endArray()
        array_expr = self.writer.stopRecordingExpression()
        self.writer.addStaticAttribute("expected_events", array_expr)

    def visit_DiagramTestExpectedSlot(self, slot):
        # write slot
        self.writer.beginArray()
        for e in slot.expected_events:
            e.accept(self)
        self.writer.endArray()

    def visit_DiagramTestEvent(self, event):
        self.writer.add(GLC.NewExpression("Event", [GLC.String(event.name), GLC.String(event.port), GLC.ArrayExpression(event.parameters)]))

    ### CLASS
    def visit_Class(self, class_node):
        """
        Generate code for Class construct
        """
        super_classes = []
        if not class_node.super_class_objs:
            # if none of the class' super classes is defined in the diagram,
            # we have to inherit RuntimeClassBase
            if class_node.statechart:
                # only inherit RuntimeClassBase if class has a statechart
                super_classes.append("RuntimeClassBase")
        if class_node.super_classes:
            for super_class in class_node.super_classes:
                super_classes.append(super_class)

        self.writer.beginClass(class_node.name, super_classes)

        # visit constructor
        class_node.constructors[0].accept(self)

        # visit destructor
        class_node.destructors[0].accept(self)
        
        # visit methods
        for i in class_node.methods:
            i.accept(self)

        # compile and initialize Statechart
        if class_node.statechart:
            class_node.statechart.accept(self)
        
            self.writer.beginMethod("initializeStatechart")
            self.writer.beginMethodBody()
            self.writer.addComment("enter default state")
            
            if self.debug_mode == 1:
                self.writer.addRawCode('print(colors.fg.yellow + "Type " + colors.fg.orange + "help" + colors.fg.yellow + " to see the available commands." + colors.reset)')
                self.writer.addAssignment("event", GLC.String("start"))
                self.createTracingEvent()

            # get effective target of initial transition
            self.writer.addAssignment(
                GLC.SelfProperty("default_targets"),
                GLC.FunctionCall(
                    GLC.Property(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(class_node.statechart.root.initial)
                        ),
                        "getEffectiveTargetStates"
                    )
                )
            )
            
            self.writer.add(GLC.SuperClassMethodCall(
                "RuntimeClassBase",
                "initializeStatechart",
                []
            ))
            
            self.writer.endMethodBody()
            self.writer.endMethod()

        self.writer.endClass()
        
    ### CLASS -- CONSTRUCTOR
    def visit_Constructor(self, constructor):
        self.writer.beginConstructor()
        if constructor.parent_class.statechart:
            self.writer.addFormalParameter("controller")
        for p in constructor.getParams():
            self.writer.addFormalParameter(p.getIdent(), p.getDefault())
        self.writer.beginMethodBody() # constructor body

        if constructor.parent_class.statechart: # main constructor
            self.writer.beginSuperClassConstructorCall("RuntimeClassBase")
            self.writer.addActualParameter("controller")
            self.writer.endSuperClassConstructorCall()

            self.writer.addVSpace()
            
            for p in constructor.parent_class.inports:
                self.writer.addAssignment(
                    GLC.MapIndexedExpression(GLC.SelfProperty("inports"), GLC.String(p)),
                    GLC.FunctionCall(GLC.Property("controller", "addInputPort"), [GLC.String(p), GLC.SelfExpression()]))

            for p in constructor.parent_class.outports:
                self.writer.addAssignment(
                    GLC.MapIndexedExpression(GLC.SelfProperty("outports"), GLC.String(p)),
                    GLC.FunctionCall(GLC.Property("controller", "addOutputPort"), [GLC.String(p), GLC.SelfExpression()]))

            if constructor.parent_class.statechart.big_step_maximality == "take_one":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "big_step_maximality"), GLC.Property("StatechartSemantics", "TakeOne"))
            elif constructor.parent_class.statechart.big_step_maximality == "take_many":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "big_step_maximality"), GLC.Property("StatechartSemantics", "TakeMany"))

            if constructor.parent_class.statechart.internal_event_lifeline == "queue":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "internal_event_lifeline"), GLC.Property("StatechartSemantics", "Queue"))
            elif constructor.parent_class.statechart.internal_event_lifeline == "next_small_step":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "internal_event_lifeline"), GLC.Property("StatechartSemantics", "NextSmallStep"))
            elif constructor.parent_class.statechart.internal_event_lifeline == "next_combo_step":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "internal_event_lifeline"), GLC.Property("StatechartSemantics", "NextComboStep"))

            if constructor.parent_class.statechart.input_event_lifeline == "first_small_step":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "input_event_lifeline"), GLC.Property("StatechartSemantics", "FirstSmallStep"))
            elif constructor.parent_class.statechart.input_event_lifeline == "first_combo_step":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "input_event_lifeline"), GLC.Property("StatechartSemantics", "FirstComboStep"))
            elif constructor.parent_class.statechart.input_event_lifeline == "whole":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "input_event_lifeline"), GLC.Property("StatechartSemantics", "Whole"))

            if constructor.parent_class.statechart.priority == "source_parent":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "priority"), GLC.Property("StatechartSemantics", "SourceParent"))
            elif constructor.parent_class.statechart.priority == "source_child":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "priority"), GLC.Property("StatechartSemantics", "SourceChild"))


            if constructor.parent_class.statechart.concurrency == "single":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "concurrency"), GLC.Property("StatechartSemantics", "Single"))
            elif constructor.parent_class.statechart.concurrency == "many":
                self.writer.addAssignment(GLC.Property(GLC.SelfProperty("semantics"), "concurrency"), GLC.Property("StatechartSemantics", "Many"))

            if self.debug_mode == 1:
                self.writer.addVSpace()
                #self.writer.addAssignment(GLC.SelfProperty("debugFlag"), "False")
                
                #self.writer.addAssignment(GLC.SelfProperty("debugFlags"), GLC.FunctionCall("Queue"))
                #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "put"), ["False"]))
                self.writer.addAssignment(GLC.SelfProperty("firstTime"), "True")
                self.writer.addAssignment(GLC.SelfProperty("didCalcs"), GLC.FunctionCall("Queue"))
                self.writer.addAssignment(GLC.SelfProperty("active_states"), GLC.FunctionCall("Queue"))
                self.writer.addAssignment(GLC.SelfProperty("startTime"), "0.0")
                self.writer.addAssignment(GLC.SelfProperty("executionTime"), "0.0")
                self.writer.addAssignment(GLC.SelfProperty("localExecutionTime"), "0.0")
                self.writer.addAssignment(GLC.SelfProperty("cumulativeDebugTime"), "0.0")
                self.writer.addAssignment(GLC.SelfProperty("tracedEvents"), GLC.ArrayExpression())
                self.writer.addAssignment(GLC.SelfProperty("debugging"), "False")
                
           
                self.writer.addAssignment(
                    GLC.SelfProperty("expiredTimestamps"), 
                    GLC.ArrayExpression([]))
                for x in range(len(self.breakpoints["timestamps"])):
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.SelfProperty("expiredTimestamps"), "append"), 
                                [GLC.FalseExpression()]))

            # if debug mode?
            self.writer.addVSpace()
            self.writer.addComment("set execution speed")
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("setSimulationSpeed")))
        
            self.writer.addVSpace()
            self.writer.addComment("build Statechart structure")
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("build_statechart_structure"), []))

        if constructor.parent_class.attributes:
            self.writer.addVSpace()
            self.writer.addComment("user defined attributes")
            for attribute in constructor.parent_class.attributes:
                if attribute.init_value is None :
                    self.writer.addAssignment(GLC.SelfProperty(attribute.name), GLC.NoneExpression())
                else :
                    self.writer.addAssignment(GLC.SelfProperty(attribute.name), attribute.init_value)
                self.attributes.append(attribute)
            
        self.writer.addVSpace()
        

        self.writer.addComment("call user defined constructor")
        self.writer.beginSuperClassMethodCall(constructor.parent_class.name, "user_defined_constructor")
        for p in constructor.getParams():
            # we can't do p.accept(self) here because 'p' is a FormalParameter
            # and we want to write it as an actual parameter
            self.writer.addActualParameter(p.getIdent())
        self.writer.endSuperClassMethodCall()
        self.writer.endMethodBody()
        self.writer.endConstructor()

        # user defined constructor
        self.writer.beginMethod("user_defined_constructor")
        for p in constructor.getParams():
            p.accept(self)
        self.writer.beginMethodBody()
        for super_class in constructor.parent_class.super_classes:
            # begin call
            if super_class in constructor.parent_class.super_class_objs:
                self.writer.beginSuperClassMethodCall(super_class, "user_defined_constructor")
            else:
                self.writer.beginSuperClassConstructorCall(super_class)
            # write actual parameters
            if super_class in constructor.super_class_parameters:
                for p in constructor.super_class_parameters[super_class]:
                    self.writer.addActualParameter(p)
            # end call
            if super_class in constructor.parent_class.super_class_objs:
                self.writer.endSuperClassMethodCall()
            else:
                self.writer.endSuperClassConstructorCall()
        self.writer.addRawCode(constructor.body)
        self.writer.endMethodBody()
        self.writer.endMethod()
        
        self.writer.beginMethod("setSimulationSpeed")
        self.writer.beginMethodBody()
        self.writer.addVSpace()
        file = open("imports/argsParser.py").read()
        self.writer.addRawCode(file)
        self.writer.endMethodBody()
        self.writer.endMethod()
        
        
    def visit_FormalParameter(self, formal_parameter):
        self.writer.addFormalParameter(formal_parameter.getIdent(), formal_parameter.getDefault())

    ### CLASS -- DESTRUCTOR
    def visit_Destructor(self, destructor):
        self.writer.beginMethod("user_defined_destructor")
        self.writer.beginMethodBody()
        if destructor.body.strip():
            self.writer.addRawCode(destructor.body)
        if destructor.parent_class.super_classes:
            self.writer.addComment("call super class destructors")
            for super_class in destructor.parent_class.super_classes:
                # begin call
                if super_class in destructor.parent_class.super_class_objs:
                    self.writer.beginSuperClassMethodCall(super_class, "user_defined_destructor")
                    self.writer.endSuperClassMethodCall()
                else:
                    self.writer.beginSuperClassDestructorCall(super_class)
                    self.writer.endSuperClassDestructorCall()
                    pass

                # self.writer.beginSuperClassMethodCall(super_class, "user_defined_destructor")
                # self.writer.endSuperClassMethodCall()
        self.writer.endMethodBody()
        self.writer.endMethod()
        
    ### CLASS -- METHOD
    def visit_Method(self, method):
        self.writer.addVSpace()
        self.writer.beginMethod(method.name, "user defined method")
        for p in method.parameters:
            p.accept(self)
        self.writer.beginMethodBody()
        # if self.debug_mode == 1:
        #     self.writer.add(GLC.FunctionCall("print", [GLC.Property(GLC.SelfProperty("current_state"), "name")]))
        #self.writer.add(GLC.FunctionCall("print", [GLC.String("Current State: "), GLC.Property(GLC.SelfProperty("current_state"), "name")]))
        self.writer.addRawCode(method.body)
        self.writer.endMethodBody()
        self.writer.endMethod()
        
    ### CLASS -- ASSOCIATION
    def visit_Association(self, association):
        self.writer.addAssignment(
            GLC.MapIndexedExpression(
                GLC.Property("instance", "associations"),
                GLC.String(association.name)),
            GLC.NewExpression("Association", [GLC.String(association.to_class), str(association.min), str(association.max)]))

    ### CLASS -- STATECHART
    def visit_StateChart(self, statechart):
        self.writer.addVSpace()
        self.writer.beginMethod("build_statechart_structure", "builds Statechart structure")
        self.writer.beginMethodBody()
        
        def writeState(s, i):
            self.writer.addVSpace()
            self.writer.addComment("state %s" % ("<root>" if s.is_root else s.new_full_name))
            index_expr = GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(s.new_full_name))
            clazz = "State"
            if s.is_parallel_state:
                clazz = "ParallelState"
            elif s.is_history:
                if s.is_history_deep:
                    clazz = "DeepHistoryState"
                else:
                    clazz = "ShallowHistoryState"
            self.writer.addAssignment(
                index_expr,
                GLC.NewExpression(clazz, [str(i), GLC.String(s.new_full_name), GLC.SelfExpression()])
            )
            if not s.is_root and not s.is_history: #added not s.is_history as history states are not supposed to have children, therefore they should not have enter or exit actions
                if s.enter_action.action or s.has_timers:
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setEnter"
                            ),
                            [GLC.SelfProperty(s.friendly_name + "_enter")]
                        )
                    )
                if s.exit_action.action or s.has_timers:
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setExit"
                            ),
                            [GLC.SelfProperty(s.friendly_name + "_exit")]
                        )
                    )
        
        # write all states
        for (i, s) in enumerate(statechart.states):
            writeState(s, i)
            
        if self.debug_mode == 1:
            debugName = "/state_Debug"
            finalStateName = "/state_Final"
            helpName = "/state_Help"
            # create DEBUG state
            self.createDebugState(debugName, i+1)
            self.createFinalState(finalStateName, i+2)
            self.createHelpState(helpName, i+3)
            self.createDebugEvents()
            self.createTransitionContainers()

        
        # add children to composite states
        self.writer.addVSpace()
        self.writer.addComment("add children")
        for (i, s) in enumerate(statechart.composites):
            for c in s.children:
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(s.new_full_name)
                            ),
                        "addChild"),
                        [GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(c.new_full_name))]
                    )
                )
                
        if self.debug_mode == 1:
            self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String("")
                                ),
                            "addChild"),
                            [GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(debugName))]
                        )
                    )
            self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String("")
                                ),
                            "addChild"),
                            [GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(finalStateName))]
                        )
                    )
            self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String("")
                                ),
                            "addChild"),
                            [GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(helpName))]
                        )
                    )
        
        # fix tree at root, such that 'descendants' and 'ancestors' fields are filled in
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(
                    GLC.MapIndexedExpression(
                        GLC.SelfProperty("states"),
                        GLC.String("")
                    ),
                    "fixTree"
                )
            )
        )
        
        # defaults
        for (i, s) in enumerate(statechart.composites):
            if not s.is_parallel_state:
                self.writer.addAssignment(
                    GLC.Property(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(s.new_full_name)
                        ),
                        "default_state"
                    ),
                    GLC.MapIndexedExpression(
                        GLC.SelfProperty("states"),
                        GLC.String(s.initial)
                    )
                )
        
        # transitions
        for s in statechart.basics + statechart.composites: #+ statechart.histories
            #if s.transitions:
            if not s.is_root:
                self.writer.addVSpace()
                self.writer.addComment("transition %s" % s.new_full_name)
                if self.debug_mode == 1:
                    self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("eventTransitions"),
                            GLC.String(s.new_full_name)
                        ), GLC.ArrayExpression())
                    self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("timedTransitions"),
                            GLC.String(s.new_full_name)
                        ), GLC.ArrayExpression())
                    self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("createdTransitions"),
                            GLC.String(s.new_full_name)
                        ), GLC.ArrayExpression())
                    self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("timeBreakpointTransitions"),
                            GLC.String(s.new_full_name)
                        ), GLC.ArrayExpression())
                    self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("genBreakpointTransitions"),
                            GLC.String(s.new_full_name)
                        ), GLC.ArrayExpression())
            for (i, t) in enumerate(s.transitions + s.else_transitions):
                # instantiate new Transition instance
                self.writer.addAssignment(
                    GLC.LocalVariableDeclaration(
                        "%s_%i" % (s.friendly_name, i)
                    ),
                    GLC.NewExpression(
                        "Transition",
                        [
                            GLC.SelfExpression(),
                            GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(s.new_full_name),
                            ),
                            GLC.ArrayExpression(
                                [
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(target_node.new_full_name)
                                    )
                                    for target_node in t.target.target_nodes
                                ]
                            )
                        ]
                    )
                )
                # if any action associated with transition: set executable_content to correct function (generated later)
                if t.action.sub_actions:
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                "%s_%i" % (s.friendly_name, i),
                                "setAction"
                            ),
                            [GLC.SelfProperty("%s_%i_exec" % (s.friendly_name, i))]
                        )
                    )
                # if any trigger associated with transition: instantiate correct Event instance
                trigger = None
                if t.trigger.is_after:
                    trigger = GLC.NewExpression("Event", [GLC.String("_%iafter" % (t.trigger.getAfterIndex()))])
                    self.numberOfAfterEvents = self.numberOfAfterEvents + 1
                elif t.trigger.event:
                    trigger = GLC.NewExpression("Event",
                                                    [
                                                        GLC.String(t.trigger.event),
                                                        GLC.NoneExpression() if t.trigger.port is None else GLC.FunctionCall(
                                                                                                                GLC.SelfProperty("getInPortName"),
                                                                                                                [GLC.String(t.trigger.port)]
                                                                                                            )
                                                    ]
                                                )
                else:
                    trigger = GLC.NoneExpression()
                if trigger:
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                "%s_%i" % (s.friendly_name, i),
                                "setTrigger"
                            ),
                            [trigger]
                        )
                    )
                # if any guard associated with transition: set guard to correct function (generated later)
                if t.guard:
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                "%s_%i" % (s.friendly_name, i),
                                "setGuard"
                            ),
                            [GLC.SelfProperty("%s_%i_guard" % (s.friendly_name, i))]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(s.new_full_name)
                            ),
                            "addTransition"
                        ),
                        ["%s_%i" % (s.friendly_name, i)]
                    )
                )
                
                if self.debug_mode == 1:
                    if t.trigger.is_after:
                        # self.writer.add(
                        #     GLC.FunctionCall(
                        #         GLC.Property(
                        #             GLC.SelfProperty("timedTransitions"),
                        #             "append"),
                        #             ["%s_%i" % (s.friendly_name, i)]
                        #     ))
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("timedTransitions"),
                                        GLC.String(s.new_full_name)
                                    ),
                                    "append"
                                ),
                                ["%s_%i" % (s.friendly_name, i)]
                            ))
                    elif t.trigger.event:
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("eventTransitions"),
                                        GLC.String(s.new_full_name)
                                    ),
                                    "append"
                                ),
                                ["%s_%i" % (s.friendly_name, i)]
                            ))
                

        toCombine = []
        for s in statechart.basics + statechart.composites: #+ statechart.histories
            if s.has_parallel_ancestor:
                toCombine.append(s)

        # for c in combinations:
        #     print(c.new_full_name)
        #print(c.new_full_name for c in combinations)
        combinations = self.get_combinations(toCombine)
        # print(len(combinations))
        # it = 0
        # for c in combinations:
        #     for s in c:
        #         if not s.parent.is_parallel_state and len(s.parent.children) > 1:
        #             print("s")
        #             #combinations.remove(it)
        #     it = it + 1

        # print(len(combinations))


        if self.debug_mode == 1:
            
            # create DEBUG transitions
            self.createAllDebugTransitions(debugName, finalStateName, helpName, statechart)
            self.createParallelTransitions(debugName, combinations)
            
        self.writer.endMethodBody()
        self.writer.endMethod()
        
        
        # enter/exit actions
        for (i, s) in enumerate(statechart.composites + statechart.basics): #+ statechart.histories
            if not s.is_root:
                if s.enter_action.action or s.has_timers:
                    s.enter_action.accept(self)
                if s.exit_action.action or s.has_timers:
                    s.exit_action.accept(self)
        
        if self.debug_mode == 1:

            self.createDebugActions(debugName)

            self.createFinalStateEnter(finalStateName)

            self.createHelpActions(helpName)

            self.chooseNextTransition()
            
            self.chooseNextInputEvent()

            self.printInternalState()

            self.printPrompt()

            self.createTracer()
        
        # transition actions and guards
        for s in statechart.composites + statechart.basics:
            for (i, t) in enumerate(s.transitions):
                if t.action.sub_actions:
                    self.writeTransitionAction(t, i)
                if t.hasGuard():
                    self.writeTransitionGuard(t, i)
        
        if self.debug_mode == 1:
            
            # debug guards
            self.createDebugGuards(statechart, combinations, debugName)
        
    def get_combinations(self, lst): # creating a user-defined method
        combination = [] # empty list 
        for r in range(2, len(lst) + 1):
            # to generate combination
            combination.extend(itertools.combinations(lst, r))
        return combination

    def visit_FormalEventParameter(self, formal_event_parameter):
        self.writer.add(formal_event_parameter.name)
        
    def writeFormalEventParameters(self, transition):
        parameters = transition.getTrigger().getParameters()
        if(len(parameters) > 0) :
            for index, parameter in enumerate(parameters):
                self.writer.startRecordingExpression()
                parameter.accept(self)
                parameter_expr = self.writer.stopRecordingExpression()
                self.writer.addAssignment(
                    GLC.LocalVariableDeclaration(parameter_expr),
                    GLC.ArrayIndexedExpression("parameters", str(index)))        
        
    def writeTransitionAction(self, transition, index):
        self.writer.beginMethod("%s_%i_exec" % (transition.parent_node.friendly_name, index))
        
        # parameters, start method
        self.writer.addFormalParameter("parameters")
        self.writer.beginMethodBody()

        # handle parameters to actually use them
        self.writeFormalEventParameters(transition)
        
        # write action
        transition.getAction().accept(self)
        
        # end method
        self.writer.endMethodBody()
        self.writer.endMethod()
        
    def writeTransitionGuard(self, transition, index):
        self.writer.beginMethod("%s_%i_guard" % (transition.parent_node.friendly_name, index))
        
        # parameters, start method
        self.writer.addFormalParameter("parameters")
        self.writer.beginMethodBody()
        
        # handle parameters to actually use them
        self.writeFormalEventParameters(transition)
        
        # get guard condition
        self.writer.startRecordingExpression()
        transition.getGuard().accept(self) # --> visit_Expression
        expr = self.writer.stopRecordingExpression()
        
        # return statement, end method
        self.writer.add(GLC.ReturnStatement(expr))
        self.writer.endMethodBody()
        self.writer.endMethod()
    
    def visit_EnterAction(self, enter_method):
        parent_node = enter_method.parent_node
        self.writer.beginMethod(parent_node.friendly_name + "_enter")
        self.writer.beginMethodBody()
        
        # set current state
        self.writer.addAssignment(
                            GLC.SelfProperty("current_state"), 
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(parent_node.new_full_name),
                            ))

        timerIndex = self.numberOfAfterEvents
        if self.debug_mode == 1:
            self.writer.addAssignment(GLC.SelfProperty("debugging"), "False")
            
            self.writer.addAssignment(
                                GLC.SelfProperty("startTime"), 
                                GLC.FunctionCall(GLC.SelfProperty("getSimulatedTime"))
            )
            self.writer.addVSpace()
            timerIndex = self.handleTimeBreakpoints(timerIndex)

            

            if parent_node.children == []:
                self.writer.beginWhileLoop(GLC.NotExpression(
                    GLC.FunctionCall(GLC.Property(GLC.SelfProperty("didCalcs"), "empty"))))
                self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("didCalcs"), "get")))
                self.writer.endWhileLoop()
      
            self.writer.add(GLC.VSpace())
            self.writer.beginElseIf(GLC.EqualsExpression(GLC.SelfProperty("firstTime"), "True"))

            self.writer.addAssignment(GLC.SelfProperty("localExecutionTime"),"0.0")

            if parent_node.children == []:
                #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "put"), ["False"]))
                self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("active_states"), "put"), [GLC.SelfProperty("current_state")]))
                self.writer.add(GLC.VSpace())

        if enter_method.action:
            enter_method.action.accept(self)

        if self.debug_mode == 1:
            self.writer.add(GLC.VSpace())
            #if parent_node.children == []:
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("print_internal_state"), [GLC.String(parent_node.new_full_name)]))
            
            self.writer.addAssignment("event", GLC.String("entry: " + parent_node.new_full_name))
            self.createTracingEvent()
            
            if parent_node.has_timers:
                self.writer.add(GLC.VSpace())
                self.writer.addAssignment("timers", GLC.ArrayExpression())
                self.writer.beginIf(GLC.DifferentExpression(GLC.SelfProperty("scaleFactor"), GLC.FunctionCall("float", [GLC.String("inf")])))

        appended = False
        hasTransition = False
        timers = []
        # take care of any AFTER events
        for transition in parent_node.transitions :
            hasTransition = True
            trigger = transition.getTrigger()
            if trigger.isAfter() :
                self.writer.startRecordingExpression()
                trigger.after.accept(self)
                after = self.writer.stopRecordingExpression()
                if self.debug_mode == 1:
                    self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"), [str(trigger.getAfterIndex()), GLC.DivisionExpression(after, GLC.SelfProperty("scaleFactor"))]))
                    self.writer.add(GLC.FunctionCall(GLC.Property("timers", "append"),[after]))
                    appended = True
                    for l in after.getExpressionList():
                        #print(l.getText())
                        timers.append((float(l.getText()), trigger.getAfterIndex()))
                    
                else:
                    self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"), [str(trigger.getAfterIndex()), after, ]))
                

        if self.debug_mode == 1:

            if appended or hasTransition:
                self.writer.add(
                    GLC.FunctionCall("print", 
                                     [GLC.AdditionExpression(
                                        GLC.AdditionExpression(
                                            GLC.Property(
                                                GLC.Property("colors", "fg"), "lightgreen"),
                                                GLC.String("Available Transition Options:")), 
                                                GLC.Property("colors", "reset"))]))

            if appended:
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("process_time_transitions"),
                                                 ["timers", GLC.String(parent_node.new_full_name)]))
                self.writer.endIf()
                
                lowest = timers[0]
                for t in timers:
                    #print(t[0])
                    if t[0] < lowest[0]:
                        lowest = t
                
                self.writer.beginElse()
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"), [str(lowest[1]), GLC.DivisionExpression(str(lowest[0]), GLC.SelfProperty("scaleFactor")), ]))
                self.writer.endElse()
    
                
            if hasTransition:
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("process_event_transitions"),
                                                 [GLC.String(parent_node.new_full_name)]))
            self.writer.add(GLC.VSpace())
            self.handleBreakpoints(parent_node, timerIndex)

            #self.writer.addRawCode('print("> "),')
            if parent_node.children == []:
                #self.printPrompt(parent_node.new_full_name)
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("print_prompt")))

            self.writer.endElseIf()
            # self.chooseNextTransition(parent_node, appended)
            # self.writer.addVSpace()
            # self.chooseNextInputEvent(parent_node, hasTransition)
            
            self.writer.beginElse()

            #if parent_node.children == []:
                #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "get")))
                #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "put"), ["False"]))
            
            for transition in parent_node.transitions :
                trigger = transition.getTrigger()
                if trigger.isAfter() :
                    self.writer.startRecordingExpression()
                    trigger.after.accept(self)
                    after = self.writer.stopRecordingExpression()
                    afterText = after.getExpressionList()[0].getText()
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.SelfProperty("addTimer"), 
                            [str(trigger.getAfterIndex()), 
                            GLC.MinusExpression(
                                str(float(afterText)),
                                GLC.DivisionExpression(
                                    GLC.DivisionExpression(
                                        GLC.SelfProperty("localExecutionTime"), 
                                        "1000.0"),
                                        GLC.SelfProperty("scaleFactor"))
                                        )]
                                        ))
        
            self.writer.addAssignment("event", GLC.String("re-entry: " + parent_node.new_full_name))
            self.createTracingEvent()

            #self.writer.addRawCode('print("> "),')
            if parent_node.children == []:
                #self.printPrompt(parent_node.new_full_name)
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("print_prompt")))


            self.writer.endElse()
        
        self.writer.endMethodBody()
        self.writer.endMethod()
         
    def visit_ExitAction(self, exit_method):
        parent_node = exit_method.parent_node
        self.writer.beginMethod(parent_node.friendly_name + "_exit")
        self.writer.beginMethodBody()        
        
        # take care of any AFTER events
        for transition in parent_node.transitions:
            trigger = transition.getTrigger()
            if trigger.isAfter():
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("removeTimer"), [str(trigger.getAfterIndex())]))
        
        if self.debug_mode == 1:
            self.writer.addAssignment("index", str(self.numberOfAfterEvents))
            self.writer.beginForLoopIterateArray(GLC.SelfProperty("expiredTimestamps"), "et")
            #self.writer.beginIf() #existe sequer algum if?
            self.writer.add(
                GLC.FunctionCall(
                    GLC.SelfProperty("removeTimer"), ["index"]))
            self.writer.addAssignment("index", GLC.AdditionExpression("index", "1"))
            self.writer.endForLoopIterateArray()


        if self.debug_mode == 0:
            if exit_method.action:
                exit_method.action.accept(self)


        if self.debug_mode == 1:
            if parent_node.children == []:
                self.writer.add(GLC.VSpace())
                self.writer.beginIf(
                                GLC.FunctionCall(GLC.Property(GLC.SelfProperty("didCalcs"), "empty")) )
                self.writer.addAssignment(GLC.SelfProperty("localExecutionTime"),
                                            GLC.AdditionExpression(
                                                GLC.SelfProperty("localExecutionTime"), 
                                                GLC.MinusExpression(
                                                    GLC.FunctionCall(
                                                        GLC.SelfProperty("getSimulatedTime")), 
                                                        GLC.SelfProperty("startTime"))
                                            ))

                self.writer.addAssignment(GLC.SelfProperty("executionTime"),
                                            GLC.AdditionExpression(
                                                GLC.SelfProperty("executionTime"), 
                                                GLC.MinusExpression(
                                                    GLC.FunctionCall(
                                                        GLC.SelfProperty("getSimulatedTime")), 
                                                        GLC.SelfProperty("startTime"))
                                            ))
                self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("didCalcs"), "put"), ["True"]))
                self.writer.endIf()

            self.writer.add(GLC.VSpace())
            self.writer.addAssignment("found", GLC.FalseExpression())
            self.writer.beginForLoopIterateArray(
                GLC.MapIndexedExpression(
                    GLC.SelfProperty("timeBreakpointTransitions"), 
                            GLC.String(parent_node.new_full_name)), "b")
            self.writer.beginIf(GLC.DifferentExpression(GLC.Property("b", "enabled_event"), GLC.NoneExpression()))
            self.writer.addAssignment("found", GLC.TrueExpression())
            self.writer.add(GLC.RawCode("timerIndex = int(b.enabled_event.name[1:2])"))
            self.writer.addAssignment("startingIndex", "3")
            self.writer.addAssignment(
                GLC.ArrayIndexedExpression(
                    GLC.SelfProperty("expiredTimestamps"),
                    GLC.MinusExpression("timerIndex", "startingIndex")), GLC.TrueExpression())

            self.writer.endIf()
            self.writer.endForLoopIterateArray()

            self.writer.add(GLC.VSpace())
            self.writer.beginForLoopIterateArray(
                GLC.MapIndexedExpression(
                    GLC.SelfProperty("genBreakpointTransitions"), 
                            GLC.String(parent_node.new_full_name)), "b")
            self.writer.beginIf(GLC.DifferentExpression(GLC.Property("b", "enabled_event"), GLC.NoneExpression()))
            self.writer.addAssignment("found", GLC.TrueExpression())

            self.writer.endIf()
            self.writer.endForLoopIterateArray()

            self.writer.add(GLC.VSpace())
            self.writer.beginIf(
                GLC.AndExpression(
                        GLC.AndExpression(
                            GLC.EqualsExpression(
                                    GLC.Property(
                                        GLC.MapIndexedExpression(
                                                GLC.SelfProperty("pauseTransitions"),
                                                GLC.String(parent_node.new_full_name),
                                        ),
                                        "enabled_event"),
                                GLC.NoneExpression()
                            ), 
                            GLC.NotExpression("found")),
                            GLC.EqualsExpression(
                                    GLC.Property(
                                        GLC.MapIndexedExpression(
                                                GLC.SelfProperty("helpTransitions"),
                                                GLC.String(parent_node.new_full_name),
                                        ),
                                        "enabled_event"),
                                GLC.NoneExpression()
                            )
                            )
            )
            # execute user-defined exit action if present
            if exit_method.action:
                exit_method.action.accept(self)

            #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "get")))
            self.writer.addAssignment(GLC.SelfProperty("firstTime"),"True")
            if parent_node.children == []:
                self.writer.addAssignment("queue", GLC.Property(GLC.SelfProperty("active_states"), "queue"))
                self.writer.beginIf(GLC.EqualsExpression(GLC.MapIndexedExpression("queue", "0"), GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(parent_node.new_full_name))))
                self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("active_states"), "get")))
                self.writer.endIf()
                self.writer.beginElse()
                self.writer.addAssignment("index", "0")
                self.writer.addAssignment("iteration", "0")
                self.writer.beginForLoopIterateArray("queue", "e")
                self.writer.beginIf(GLC.EqualsExpression(GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(parent_node.new_full_name)), "e"))
                self.writer.addAssignment("index", "iteration")
                self.writer.endIf()
                self.writer.addAssignment("iteration", GLC.AdditionExpression("iteration", "1"))
                self.writer.endForLoopIterateArray()
                self.writer.addRawCode("del self.active_states.queue[index]")
                self.writer.endElse()

            self.writer.endIf()
            self.writer.add(GLC.VSpace())

            #create allTransitions
            self.writer.addAssignment("allTransitions", GLC.ArrayExpression())
            # self.writer.beginForLoopIterateArray(
            #     GLC.SelfProperty("timedTransitions"), "t"
            # )
            # self.writer.addAssignment(
            #     "source", GLC.Property(GLC.Property("t", "source"), "name")
            #     )
            # self.writer.beginIf(
            #     GLC.EqualsExpression(
            #         "source", 
            #         GLC.String(parent_node.new_full_name)
            #             ))
            # self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "append"),["t"]))
            # self.writer.endIf()

            # self.writer.endForLoopIterateArray()
            #if parent_node.children == []:
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "extend"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("timedTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "extend"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("eventTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "extend"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("timeBreakpointTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "extend"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("genBreakpointTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "extend"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("createdTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "append"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("stopTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "append"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("pauseTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            self.writer.add(GLC.FunctionCall(GLC.Property("allTransitions", "append"),
                                [GLC.MapIndexedExpression(
                                    GLC.SelfProperty("helpTransitions"), 
                                    GLC.String(parent_node.new_full_name))]))
            #saveEvent
            self.writer.addAssignment("event", GLC.String("exit: " + parent_node.new_full_name))
            self.writer.beginForLoopIterateArray("allTransitions", "tr")
            self.writer.beginIf(
                GLC.NotExpression(
                    GLC.EqualsExpression(
                        GLC.Property("tr","enabled_event"), 
                        GLC.NoneExpression())
                        ))
            self.writer.addAssignment("event", 
                                      GLC.AdditionExpression("event",
                                      GLC.AdditionExpression(
                                          GLC.String(" - "),
                                          GLC.Property(
                                              GLC.Property("tr", "enabled_event"), "name")))
            )
            self.writer.endIf()
            self.writer.endForLoopIterateArray()
            
            self.createTracingEvent()
            # self.writer.addAssignment("allAttTuples", GLC.ArrayExpression())
            # for a in self.attributes:
            #     self.writer.add(
            #         GLC.FunctionCall(
            #             GLC.Property("allAttTuples", "append"), 
            #             [GLC.ArrayExpression([GLC.String(a.name), GLC.SelfProperty(a.name)])]))

            # self.writer.add(
            #     GLC.FunctionCall(
            #         GLC.SelfProperty("saveEvent"),
            #         ["event", 
            #             GLC.FunctionCall(
            #                 GLC.SelfProperty("getSimulatedTime")),
            #             "allAttTuples"]))
        
        self.writer.endMethodBody()
        self.writer.endMethod()        
            
    # helper method
    def writeEnterHistory(self, entered_node, is_deep):
        ### OLD CODE (TODO)
        self.writer.beginMethod("enterHistory" + ("Deep" if is_deep else "Shallow") + "_" + entered_node.full_name)
        self.writer.beginMethodBody()

        self.writer.beginIf(GLC.EqualsExpression(
            GLC.ArrayLength(
                GLC.MapIndexedExpression(
                    GLC.SelfProperty("history_state"),
                    GLC.SelfProperty(entered_node.full_name))),
            "0"))
        defaults = entered_node.defaults

        for node in defaults:
            if node.is_basic :
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enter_"+node.full_name)))
            elif node.is_composite :
                self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enterDefault_"+node.full_name)))

        self.writer.endIf()
        self.writer.beginElse()
        children = entered_node.children
        if entered_node.is_parallel_state:
            for child in children:
                if not child.is_history :
                    self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enter_"+child.full_name)))
                    self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enterHistory"+("Deep" if is_deep else "Shallow")+"_"+child.full_name)))
        else:
            for child in children:
                if not child.is_history :
                    self.writer.beginIf(GLC.ArrayContains(
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("history_state"),
                            GLC.SelfProperty(entered_node.full_name)),
                        GLC.SelfProperty(child.full_name)))
                    if child.is_composite:
                        if is_deep :
                            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enter_"+child.full_name)))
                            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enterHistoryDeep_"+child.full_name)))
                        else :
                            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enterDefault_"+child.full_name)))
                    else:
                        self.writer.add(GLC.FunctionCall(GLC.SelfProperty("enter_"+child.full_name)))
                    self.writer.endIf()
        self.writer.endElse()

        self.writer.endMethodBody()
        self.writer.endMethod()

    def visit_SelfReference(self, self_reference):
        self.writer.add(GLC.SelfExpression())

    def visit_StateReference(self, state_ref):
        self.writer.beginArray()
        for node in state_ref.getNodes():
            self.writer.add(GLC.SelfProperty(node.full_name))
        self.writer.endArray()

    def visit_InStateCall(self, in_state_call):
        self.writer.add(
            GLC.FunctionCall(
                GLC.SelfProperty("inState"),
                [
                    GLC.ArrayExpression(
                        [GLC.String(target_node.new_full_name) for target in in_state_call.targets for target_node in target.target_nodes]
                    )
                ]
            )
        )
        
    def visit_ElseGuard(self, else_guard):
        self.writer.add(
            GLC.String("ELSE_GUARD")
        )

    def visit_Expression(self, expression):
        self.writer.startRecordingExpression()
        self.writer.beginGlue()
        for part in expression.expression_parts:
            part.accept(self)
        self.writer.endGlue()
        expr = self.writer.stopRecordingExpression()
        self.writer.add(expr)

    def visit_ExpressionPartString(self, e):
        self.writer.add(e.string)
        
    def visit_RaiseEvent(self, raise_event):
        self.writer.startRecordingExpression()
        self.writer.begin(GLC.NewExpression("Event"))

        self.writer.addActualParameter(GLC.String(raise_event.getEventName()))
        if raise_event.isOutput():
            self.writer.addActualParameter(
                                            GLC.FunctionCall(
                                                                GLC.SelfProperty("getOutPortName"),
                                                                [GLC.String(raise_event.getPort())]
                                                            )
                                            )
        else:
            self.writer.addActualParameter(GLC.NoneExpression())

        self.writer.end()
        new_event_expr = self.writer.stopRecordingExpression()

        self.writer.startRecordingExpression()
        self.writer.beginArray()
        if raise_event.isCD():
            self.writer.add(GLC.SelfExpression())
        for param in raise_event.getParameters() :
            param.accept(self) # -> visit_Expression will cause expressions to be added to array
        self.writer.endArray()
        parameters_array_expr = self.writer.stopRecordingExpression()
        new_event_expr.getActualParameters().add(parameters_array_expr)

        if raise_event.isNarrow():
            self.writer.add(GLC.FunctionCall(
                GLC.Property(GLC.SelfProperty("big_step"), "outputEventOM"), [
                    GLC.NewExpression("Event", [
                        GLC.String("narrow_cast"),
                        GLC.NoneExpression(),
                        GLC.ArrayExpression([
                            GLC.SelfExpression(),
                            raise_event.getTarget(),
                            new_event_expr])])]))
        elif raise_event.isLocal():
            self.writer.add(GLC.FunctionCall(
                GLC.SelfProperty("raiseInternalEvent"),
                [new_event_expr]))
        elif raise_event.isOutput():
            self.writer.add(GLC.FunctionCall(
                GLC.Property(GLC.SelfProperty("big_step"), "outputEvent"),
                [new_event_expr]))
        elif raise_event.isCD():
            self.writer.add(GLC.FunctionCall(
                GLC.Property(GLC.SelfProperty("big_step"), "outputEventOM"),
                [new_event_expr]))
        elif raise_event.isBroad():
            self.writer.add(GLC.FunctionCall(
                GLC.Property(GLC.SelfProperty("big_step"), "outputEventOM"),
                [GLC.NewExpression("Event", [
                    GLC.String("broad_cast"),
                    GLC.NoneExpression(),
                    GLC.ArrayExpression([
                        GLC.SelfExpression(),
                        new_event_expr])])]))
            
    def visit_Script(self, script):
        self.writer.addRawCode(script.code)
        
    def visit_Log(self, log):
        self.writer.add(GLC.LogStatement(log.message))
        
    def visit_Assign(self, assign):
        self.writer.startRecordingExpression()
        assign.lvalue.accept(self) # --> visit_Expression
        lvalue = self.writer.stopRecordingExpression()
        self.writer.startRecordingExpression()
        assign.expression.accept(self) # --> visit_Expression
        rvalue = self.writer.stopRecordingExpression()
        self.writer.addAssignment(lvalue, rvalue)

    def createDebugState(self, debugName, index):
        self.writer.addVSpace()    
        self.writer.addComment(("state " + debugName))
        index_expr = GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(debugName))
        clazz = "State"
        self.writer.addAssignment(
                index_expr,
                GLC.NewExpression(clazz, [str(index), GLC.String(debugName), GLC.SelfExpression()])
                )
        self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setEnter"
                            ),
                            [GLC.SelfProperty("_" + debugName[1:] + "_enter")]
                        )
                    )
        
        self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setExit"
                            ),
                            [GLC.SelfProperty("_" + debugName[1:] + "_exit")]
                        )
                    )
        
    def createFinalState(self, finalName, index):
        self.writer.addVSpace()    
        self.writer.addComment(("state " + finalName))
        index_expr = GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(finalName))
        clazz = "State"
        self.writer.addAssignment(
                index_expr,
                GLC.NewExpression(clazz, [str(index), GLC.String(finalName), GLC.SelfExpression()])
                )
        self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setEnter"
                            ),
                            [GLC.SelfProperty("_" + finalName[1:] + "_enter")]
                        )
                    )
        
        # self.writer.add(
        #                 GLC.FunctionCall(
        #                     GLC.Property(
        #                         index_expr,
        #                         "setExit"
        #                     ),
        #                     [GLC.SelfProperty("_" + finalName[1:] + "_exit")]
        #                 )
        #             )

    def createHelpState(self, helpName, index):
        self.writer.addVSpace()    
        self.writer.addComment(("state " + helpName))
        index_expr = GLC.MapIndexedExpression(GLC.SelfProperty("states"), GLC.String(helpName))
        clazz = "State"
        self.writer.addAssignment(
                index_expr,
                GLC.NewExpression(clazz, [str(index), GLC.String(helpName), GLC.SelfExpression()])
                )
        self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setEnter"
                            ),
                            [GLC.SelfProperty("_" + helpName[1:] + "_enter")]
                        )
                    )
        
        self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                index_expr,
                                "setExit"
                            ),
                            [GLC.SelfProperty("_" + helpName[1:] + "_exit")]
                        )
                    )

    def createDebugEvents(self):
        # create DEBUG events
        self.writer.addVSpace()
        self.writer.addComment("debug events")
        self.writer.addAssignment(
            "pauseEvent", 
            GLC.NewExpression("Event", 
                            [GLC.String("pause"),
                            GLC.FunctionCall(
                                    GLC.SelfProperty("getInPortName"),
                                    [GLC.String("input")]
                            )]
                            )
            )
        
        self.writer.addAssignment(
            "stopEvent", 
            GLC.NewExpression("Event", 
                            [GLC.String("stop"),
                            GLC.FunctionCall(
                                    GLC.SelfProperty("getInPortName"),
                                    [GLC.String("input")]
                            )]
                            )
            )

        self.writer.addAssignment(
            "continueEvent", 
            GLC.NewExpression("Event", 
                            [GLC.String("continue"),
                            GLC.FunctionCall(
                                    GLC.SelfProperty("getInPortName"),
                                    [GLC.String("input")]
                            )]
                            )
            )
        self.writer.addAssignment(
            "helpEvent", 
            GLC.NewExpression("Event", 
                            [GLC.String("help"),
                            GLC.FunctionCall(
                                    GLC.SelfProperty("getInPortName"),
                                    [GLC.String("input")]
                            )]
                            )
            )

    def createTransitionContainers(self):
        # store debug transitions
        self.writer.addVSpace()
        self.writer.addComment("debug transitions")
        self.writer.addAssignment(
            GLC.SelfProperty("pauseTransitions"), "{}")
        # self.writer.addAssignment(
        #     GLC.SelfProperty("timedTransitions"), GLC.ArrayExpression())
        self.writer.addAssignment(
            GLC.SelfProperty("timedTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("eventTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("createdTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("stopTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("helpTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("timeBreakpointTransitions"), "{}")
        self.writer.addAssignment(
            GLC.SelfProperty("genBreakpointTransitions"), "{}")

    def createAllDebugTransitions(self, debugName, finalName, helpName, statechart):
        self.writer.addVSpace()
        self.writer.addComment("transitions " + debugName)
        self.numberOfAfterEvents = self.numberOfAfterEvents + 1

        # debug to help
        debugToHelp = "%s_to_%s" % (debugName[1:], helpName[1:])
        self.writer.addComment(debugName + " to "+ helpName)      
        self.writer.addAssignment(
                GLC.LocalVariableDeclaration(debugToHelp),
                GLC.NewExpression(
                    "Transition",
                    [
                        GLC.SelfExpression(),
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(debugName),
                        ),
                        GLC.ArrayExpression(
                            [
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(helpName)
                                )
                            ]
                        )
                    ]
                )
            )
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(debugToHelp,"setTrigger"),["helpEvent"])
                        )
        
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(
                    GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(debugName),
                        ),
                "addTransition"), 
                [debugToHelp]
            )
        )
        
        self.writer.addVSpace()

        # help to debug
        helpToDebug = "%s_to_%s" % (helpName[1:], debugName[1:])
        self.writer.addComment(helpName + " to "+ debugName)      
        self.writer.addAssignment(
                GLC.LocalVariableDeclaration(helpToDebug),
                GLC.NewExpression(
                    "Transition",
                    [
                        GLC.SelfExpression(),
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(helpName),
                        ),
                        GLC.ArrayExpression(
                            [
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(debugName)
                                )
                            ]
                        )
                    ]
                )
            )
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(helpToDebug,"setTrigger"),[GLC.NewExpression("Event", [GLC.String("_"+ str(self.numberOfAfterEvents-1)+"after")])])
                        )

        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(helpToDebug,"setGuard"),[GLC.SelfProperty("continueGuard_%s" % debugName[1:])])
                        )        
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(
                    GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(helpName),
                        ),
                "addTransition"), 
                [helpToDebug]
            )
        )

        self.writer.addVSpace()

        # debug to final
        debugToFinal = "%s_to_%s" % (debugName[1:], finalName[1:])
        self.writer.addComment(debugName + " to "+ finalName)      
        self.writer.addAssignment(
                GLC.LocalVariableDeclaration(debugToFinal),
                GLC.NewExpression(
                    "Transition",
                    [
                        GLC.SelfExpression(),
                        GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(debugName),
                        ),
                        GLC.ArrayExpression(
                            [
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(finalName)
                                )
                            ]
                        )
                    ]
                )
            )
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(debugToFinal,"setTrigger"),[GLC.NewExpression("Event", [GLC.String("stop")])])
                        )
   
        self.writer.add(
            GLC.FunctionCall(
                GLC.Property(
                    GLC.MapIndexedExpression(
                            GLC.SelfProperty("states"),
                            GLC.String(debugName),
                        ),
                "addTransition"), 
                [debugToFinal]
            )
        )
        self.writer.addAssignment(GLC.SelfProperty("debugToFinal"), debugToFinal)

        self.writer.addVSpace()


        for s in statechart.states:
            # if s.parent != None:
            #     for c in s.parent.children:
            #         print(c.new_name)
            if not s.is_root:
                # transition TO debug state
                toDebugTransName = "%s_to_%s" % (s.friendly_name, debugName[1:])
                self.writer.addComment(s.friendly_name + " to "+ debugName)      
                self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(toDebugTransName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                                GLC.ArrayExpression(
                                    [
                                        GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(debugName)
                                        )
                                    ]
                                )
                            ]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(toDebugTransName,"setTrigger"),["pauseEvent"])
                                )
                
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                        "addTransition"), 
                        [toDebugTransName]
                    )
                )
                
                self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                                    GLC.SelfProperty("pauseTransitions"),
                                    GLC.String(s.new_full_name),
                                ), toDebugTransName
                        )
                
                self.writer.addVSpace()

                # transition FROM debug state
                fromTransName = "_%s_to_%s" % (debugName[1:], s.friendly_name[1:])
                self.writer.addComment(s.friendly_name[1:] + " from "+ debugName)
                self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(fromTransName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(debugName)
                                        ),
                                GLC.ArrayExpression(
                                    [    
                                        GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(s.new_full_name),
                                        )
                                    ]
                                )
                            ]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(fromTransName, "setTrigger"),["continueEvent"])
                                )
                
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(fromTransName, "setGuard"), [GLC.SelfProperty("continueGuard%s" % s.friendly_name)]
                    )
                )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(debugName),
                                ),
                        "addTransition"), 
                        [fromTransName]
                    )
                )
                self.writer.addVSpace()

                # transition TO help state
                toHelpTransName = "%s_to_%s" % (s.friendly_name, helpName[1:])
                self.writer.addComment(s.friendly_name + " to "+ helpName)      
                self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(toHelpTransName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                                GLC.ArrayExpression(
                                    [
                                        GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(helpName)
                                        )
                                    ]
                                )
                            ]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(toHelpTransName,"setTrigger"),["helpEvent"])
                                )
                
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                        "addTransition"), 
                        [toHelpTransName]
                    )
                )
                
                self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                                    GLC.SelfProperty("helpTransitions"),
                                    GLC.String(s.new_full_name),
                                ), toHelpTransName
                        )
                
                self.writer.addVSpace()

                # transition FROM help state
                fromHelpTransName = "_%s_to_%s" % (helpName[1:], s.friendly_name[1:])
                self.writer.addComment(s.friendly_name[1:] + " from "+ helpName)
                self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(fromHelpTransName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(helpName)
                                        ),
                                GLC.ArrayExpression(
                                    [    
                                        GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(s.new_full_name),
                                        )
                                    ]
                                )
                            ]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(fromHelpTransName, "setTrigger"),[GLC.NewExpression("Event", [GLC.String("_"+ str(self.numberOfAfterEvents-1)+"after")])])
                                )
                
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(fromHelpTransName, "setGuard"), [GLC.SelfProperty("continueGuard%s" % s.friendly_name)]
                    )
                )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(helpName),
                                ),
                        "addTransition"), 
                        [fromHelpTransName]
                    )
                )
                self.writer.addVSpace()

                # transition TO final state
                toFinalTransName = "%s_to_%s" % (s.friendly_name, finalName[1:])
                self.writer.addComment(s.friendly_name + " to "+ finalName)      
                self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(toFinalTransName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                                GLC.ArrayExpression(
                                    [
                                        GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(finalName)
                                        )
                                    ]
                                )
                            ]
                        )
                    )
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(toFinalTransName,"setTrigger"),["stopEvent"])
                                )       
                self.writer.add(
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(s.new_full_name),
                                ),
                        "addTransition"), 
                        [toFinalTransName]
                    )
                )
                
                self.writer.addAssignment(
                        GLC.MapIndexedExpression(
                                    GLC.SelfProperty("stopTransitions"),
                                    GLC.String(s.new_full_name),
                                ), toFinalTransName
                        )

                self.writer.addVSpace()

        
        iteration = 0
        #timerIndex = timerIndex + 1
        
        timerIndex = self.numberOfAfterEvents
        for b in self.breakpoints["timestamps"]:
            for s in statechart.states:
                if not s.is_root:
                    transitionName = "timeBreakpoint%i" % (iteration)
                    self.writer.addAssignment(
                    GLC.LocalVariableDeclaration(transitionName),
                    GLC.NewExpression(
                        "Transition",
                        [
                            GLC.SelfExpression(),
                            GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(s.new_full_name),
                            ),
                            GLC.ArrayExpression(
                                [
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(debugName)
                                        )
                                    ]
                                )
                            ]
                        )
                    )

                    eventName = "_%iafter" % (timerIndex)
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(transitionName,"setTrigger"),
                            [GLC.NewExpression(
                                "Event", [GLC.String(eventName)]) ]
                        )
                    )
                        
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(s.new_full_name),
                                    ),
                            "addTransition"), 
                            [transitionName]
                        )
                    )
                    if s.children == []:
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("timeBreakpointTransitions"),
                                        GLC.String(s.new_full_name)
                                    ),
                                    "append"
                                ),
                                [transitionName]
                            ))
                    iteration = iteration + 1
                    self.writer.addVSpace()
            timerIndex = timerIndex + 1    

        #timerIndex = self.numberOfAfterEvents + breakpointIndex + 1
        iteration = 0
        if self.breakpoints['variables']:
            for s in statechart.states:
                if not s.is_root:
                    transitionName = "varBreakpoint%i" % (iteration)
                    self.writer.addAssignment(
                    GLC.LocalVariableDeclaration(transitionName),
                    GLC.NewExpression(
                        "Transition",
                        [
                            GLC.SelfExpression(),
                            GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(s.new_full_name),
                            ),
                            GLC.ArrayExpression(
                                [
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(debugName)
                                        )
                                    ]
                                )
                            ]
                        )
                    )

                    eventName = "_%iafter" % (timerIndex)
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(transitionName,"setTrigger"),
                            [GLC.NewExpression(
                                "Event", [GLC.String(eventName)]) ]
                        )
                    )
                        
                    self.writer.add(
                        GLC.FunctionCall(
                            GLC.Property(
                                GLC.MapIndexedExpression(
                                        GLC.SelfProperty("states"),
                                        GLC.String(s.new_full_name),
                                    ),
                            "addTransition"), 
                            [transitionName]
                        )
                    )
                    if s.children == []:
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(
                                    GLC.MapIndexedExpression(
                                        GLC.SelfProperty("genBreakpointTransitions"),
                                        GLC.String(s.new_full_name)
                                    ),
                                    "append"
                                ),
                                [transitionName]
                            ))
                    iteration = iteration + 1
                    self.writer.addVSpace()

        #breakpointIndex = -1
        timerIndex = timerIndex + 1

        for k,v in self.breakpoints['states'].items():
            stateName = k
            for s in statechart.states:
                if s.new_full_name == stateName:
                    #if s.children == []:
                        breakpointIndex = v
                        transitionName = "breakpoint%i" % (breakpointIndex)
                        self.writer.addAssignment(
                        GLC.LocalVariableDeclaration(transitionName),
                        GLC.NewExpression(
                            "Transition",
                            [
                                GLC.SelfExpression(),
                                GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(stateName),
                                ),
                                GLC.ArrayExpression(
                                    [
                                        GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(debugName)
                                            )
                                        ]
                                    )
                                ]
                            )
                        )

                        eventName = "_%iafter" % (timerIndex)
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(transitionName,"setTrigger"),
                                [GLC.NewExpression(
                                    "Event", [GLC.String(eventName)]) ]
                            )
                        )
                            
                        self.writer.add(
                            GLC.FunctionCall(
                                GLC.Property(
                                    GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(stateName),
                                        ),
                                "addTransition"), 
                                [transitionName]
                            )
                        )
                        
                        self.writer.add(
                                GLC.FunctionCall(
                                    GLC.Property(
                                        GLC.MapIndexedExpression(
                                            GLC.SelfProperty("genBreakpointTransitions"),
                                            GLC.String(stateName)
                                        ),
                                        "append"
                                    ),
                                    [transitionName]
                                ))
                        self.writer.addVSpace()
                        #timerIndex = timerIndex + 1

    def createParallelTransitions(self, debugName, combinations):
        iteration = 0
        for c in combinations:
            targets=[]
            for s in c:
                targets.append(GLC.MapIndexedExpression(GLC.SelfProperty("states"),GLC.String(s.new_full_name),))
            fromTransName = "_%s_to_comb%s" % (debugName[1:], iteration)
            self.writer.addComment("comb" + str(iteration))
            self.writer.addAssignment(
                    GLC.LocalVariableDeclaration(fromTransName),
                    GLC.NewExpression(
                        "Transition",
                        [
                            GLC.SelfExpression(),
                            GLC.MapIndexedExpression(
                                    GLC.SelfProperty("states"),
                                    GLC.String(debugName)
                                    ),
                            GLC.ArrayExpression(
                                targets
                            )
                        ]
                    )
                )
            self.writer.add(
                GLC.FunctionCall(
                    GLC.Property(fromTransName, "setTrigger"),["continueEvent"])
                            )
            
            self.writer.add(
                GLC.FunctionCall(
                    GLC.Property(fromTransName, "setGuard"), [GLC.SelfProperty("continueGuardComb%s" % iteration)]
                )
            )
            self.writer.add(
                GLC.FunctionCall(
                    GLC.Property(
                        GLC.MapIndexedExpression(
                                GLC.SelfProperty("states"),
                                GLC.String(debugName),
                            ),
                    "addTransition"), 
                    [fromTransName]
                )
            )
            self.writer.addVSpace()
            iteration = iteration + 1

    def createDebugActions(self, debugName):
        #create enter debug state
        self.writer.beginMethod("_" + debugName[1:] + "_enter")
        self.writer.beginMethodBody()
        

        self.writer.beginIf(GLC.SelfProperty("firstTime"))
        #self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "get")))
        self.writer.addAssignment(GLC.SelfProperty("firstTime"), "False")
        self.writer.endIf()
        self.writer.addAssignment(GLC.SelfProperty("debugging"), "True")

        # self.writer.addAssignment("nFlags", "0")
        # self.writer.beginWhileLoop(GLC.NotExpression(
        #         GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "empty"))))
        # self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "get")))
        # self.writer.addAssignment("nFlags", GLC.AdditionExpression("nFlags", "1"))
        # self.writer.endWhileLoop()

        # #self.writer.addAssignment("n", GLC.FunctionCall("range",["nFlags"]))

        # self.writer.beginForLoopIterateArray( GLC.FunctionCall("range",["nFlags"]), "x")
        # #self.writer.beginForLoopIterateMapValues(GLC.FunctionCall("range","nFlags"), "x")
        # self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("debugFlags"), "put"), ["True"]))
        # #self.writer.endForLoopIterateMapValues()
        # self.writer.endForLoopIterateArray()


        prop = GLC.Property(GLC.SelfProperty("active_states"), "queue")
        # transitionName = "newTransition"
        # objectType = "Transition"
        # eventName = "continue"
        self.writer.addAssignment("targets", GLC.FunctionCall("list", [prop]))
        #self.writer.addAssignment("source", GLC.ArrayIndexedExpression(GLC.SelfProperty("states"), GLC.String(debugName)))
        #self.writer.beginForLoopIterateArray("targets", "s")
        # self.writer.addAssignment(transitionName, 
        #                           GLC.NewExpression(
        #                               objectType, 
        #                               [GLC.SelfExpression(),
        #                                "source",
        #                                "targets"])) #GLC.ArrayIndexedExpression("", "s")
        
        # self.writer.add(
        #     GLC.FunctionCall(
        #         GLC.Property(transitionName,"setTrigger"),
        #         [GLC.NewExpression(
        #             "Event", [GLC.String(eventName),
        #                       GLC.FunctionCall(
        #                           GLC.SelfProperty("getInPortName"), [GLC.String("input")])]) ]
        #     )
        # )
            
        # self.writer.add(
        #     GLC.FunctionCall(
        #         GLC.Property("source", "addTransition"), 
        #         [transitionName]
        # ))

        self.writer.add(GLC.RawCode("states_names = [s.name for s in targets]"))

        
        #self.writer.endForLoopIterateArray()

        self.writer.addVSpace()
        self.writer.addRawCode('print(colors.fg.lightred),')
        self.writer.add(GLC.FunctionCall("print",[GLC.String("DEBUG MODE")]))
        #self.writer.add(GLC.FunctionCall("print", [GLC.String("Current State: "), GLC.Property(GLC.SelfProperty("current_state"), "name")]))
        self.writer.add(GLC.RawCode('print("Current States: {}".format(states_names))'))
        for atr in self.attributes:
            self.writer.add(
                GLC.FunctionCall("print", [
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.AdditionExpression(
                            GLC.String(atr.name), GLC.String(": {}")
                        ), "format"), [GLC.SelfProperty(atr.name)]
                    )
                ]))
        self.writer.addRawCode('print(colors.reset),')        
        #self.writer.addRawCode('print("> "),')
        #self.writer.add(GLC.FunctionCall("print_prompt"))
        #self.printPrompt(debugName)
        self.writer.addRawCode('print(colors.fg.lightgrey +"['+ debugName +'] > "+colors.reset),')

        
        self.writer.endMethodBody()
        self.writer.endMethod()

        #create exit debug state
        self.writer.beginMethod("_" + debugName[1:] + "_exit")
        self.writer.beginMethodBody()
        
        self.writer.addAssignment(GLC.SelfProperty("cumulativeDebugTime"),
                                  GLC.MinusExpression(
                                      GLC.FunctionCall(GLC.SelfProperty("getSimulatedTime")), 
                                      GLC.SelfProperty("executionTime")))
                                                
        self.writer.addAssignment("targets", GLC.FunctionCall("list", [prop]))
        self.writer.beginForLoopIterateArray("targets", "t")
        self.writer.addAssignment(
            GLC.Property(
                GLC.ArrayIndexedExpression(
                    GLC.SelfProperty("pauseTransitions"),
                    GLC.Property("t","name")
                ),
                "enabled_event"),
            GLC.NoneExpression())

        self.writer.endForLoopIterateArray()

        self.writer.beginIf(
            GLC.DifferentExpression(
                GLC.Property( 
                GLC.SelfProperty("debugToFinal"),
                "enabled_event"),
            GLC.NoneExpression()))
        
        self.writer.addAssignment("event", GLC.String("stop"))
        self.createTracingEvent()

        self.writer.endIf()

        self.writer.endMethodBody()
        self.writer.endMethod()

    def createFinalStateEnter(self, finalName):
        #create enter debug state
        self.writer.beginMethod("_" + finalName[1:] + "_enter")
        self.writer.beginMethodBody()
        self.writer.addAssignment("outputName", GLC.String("executionTrace"))
        self.writer.add(GLC.FunctionCall(GLC.Property(GLC.SelfProperty("controller"), "stop"), []))
        self.writer.add(GLC.FunctionCall(GLC.SelfProperty("saveExecutionTrace"), ["outputName"]))
        self.writer.add(GLC.FunctionCall("exit", ["1"]))
        self.writer.endMethodBody()
        self.writer.endMethod()

    def createHelpActions(self, helpName):
        self.writer.beginMethod("_" + helpName[1:] + "_enter")
        self.writer.beginMethodBody()
        self.writer.beginIf(GLC.SelfProperty("firstTime"))
        self.writer.addAssignment(GLC.SelfProperty("firstTime"), "False")
        self.writer.endIf()
        file = open("imports/help.py").read()
        self.writer.addRawCode(file)
        self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"), [str(self.numberOfAfterEvents-1), "0"]))
        self.writer.endMethodBody()
        self.writer.endMethod()

        self.writer.addVSpace()

        self.writer.beginMethod("_" + helpName[1:] + "_exit")
        self.writer.beginMethodBody()
        self.writer.add(GLC.FunctionCall(GLC.SelfProperty("removeTimer"), [str(self.numberOfAfterEvents-1)]))
        self.writer.addAssignment("targets", GLC.FunctionCall("list", [GLC.Property(GLC.SelfProperty("active_states"), "queue")]))
        self.writer.beginForLoopIterateArray("targets", "t")
        self.writer.addAssignment(
            GLC.Property(
                GLC.ArrayIndexedExpression(
                    GLC.SelfProperty("helpTransitions"),
                    GLC.Property("t","name")
                ),
                "enabled_event"),
            GLC.NoneExpression())

        self.writer.endForLoopIterateArray()
        self.writer.endMethodBody()
        self.writer.endMethod()

    def createTracer(self):
        self.writer.beginMethod("saveExecutionTrace")
        self.writer.addFormalParameter("outputName")
        self.writer.beginMethodBody()
        file = open("imports/executionTracer.py").read()
        self.writer.addRawCode(file)
        self.writer.endMethodBody()
        self.writer.endMethod()
        self.writer.beginMethod("saveEvent")
        self.writer.addFormalParameter("event_name")
        self.writer.addFormalParameter("timestamp")
        self.writer.addFormalParameter("attribute_values")
        self.writer.beginMethodBody()

        self.writer.add(GLC.FunctionCall(
            GLC.Property(GLC.SelfProperty("tracedEvents"), "append"),
            [GLC.NewExpression("TracedEvent", ["event_name", "timestamp", "attribute_values"])]
            ))

        self.writer.endMethodBody()
        self.writer.endMethod()

        self.writer.beginMethod("listContains")
        self.writer.addFormalParameter("transitions")
        self.writer.addFormalParameter("newTransition")
        self.writer.beginMethodBody()
        self.writer.addAssignment("flag", "False")
        self.writer.beginForLoopIterateArray("transitions", "t")
        sourceEq = GLC.EqualsExpression(
            GLC.Property("t", "source"),
            GLC.Property("newTransition", "source")
        )
        targetsEq = GLC.EqualsExpression(
            GLC.Property("t", "targets"),
            GLC.Property("newTransition", "targets")
        )
        triggerNameEq = GLC.EqualsExpression(
            GLC.Property(
                GLC.Property("t", "trigger"),"name"),
            GLC.Property(
                GLC.Property("newTransition", "trigger"),"name")
        )
        triggerPortEq = GLC.EqualsExpression(
            GLC.Property(
                GLC.Property("t", "trigger"),"port"),
            GLC.Property(
                GLC.Property("newTransition", "trigger"),"port")
        )
        actionEq = GLC.EqualsExpression(
            GLC.Property("t", "action"),
            GLC.Property("newTransition", "action")
        )
        self.writer.beginIf(
                GLC.AndExpression(
                    GLC.AndExpression(
                        GLC.AndExpression(
                            GLC.AndExpression(sourceEq, targetsEq), triggerNameEq
                        ), triggerPortEq
                    ), actionEq
                )
            )
        self.writer.addAssignment("flag", "True")

        self.writer.endIf()
        self.writer.endForLoopIterateArray()
        self.writer.add(GLC.ReturnStatement("flag"))
        self.writer.endMethodBody()
        self.writer.endMethod()

    def createDebugGuards(self, statechart, combinations, debugName):
        self.writer.beginMethod("continueGuard_%s" % debugName[1:])
        self.writer.addFormalParameter("parameters")
        self.writer.beginMethodBody()       
        self.writer.add(
                    GLC.ReturnStatement(GLC.SelfProperty("debugging"))
                )
        self.writer.endMethodBody()
        self.writer.endMethod()      
        for s in statechart.states:
            if not s.is_root:
                self.writer.beginMethod("continueGuard%s" % s.friendly_name)
                self.writer.addFormalParameter("parameters")
                self.writer.beginMethodBody()             
                self.writer.add(
                    GLC.ReturnStatement(
                        GLC.EqualsExpression(
                            #GLC.SelfProperty("current_state"), 
                            GLC.FunctionCall("list", [GLC.Property(GLC.SelfProperty("active_states"), "queue")]),
                                        GLC.FunctionCall("list",[GLC.ArrayExpression([GLC.MapIndexedExpression(
                                            GLC.SelfProperty("states"),
                                            GLC.String(s.new_full_name))])],
                                        )
                                    )
                    )
                )
                
                self.writer.endMethodBody()
                self.writer.endMethod()

        iteration = 0
        for c in combinations:
            targets=[]
            for s in c:
                targets.append(GLC.MapIndexedExpression(GLC.SelfProperty("states"),GLC.String(s.new_full_name),))
                
            self.writer.beginMethod("continueGuardComb%s" % iteration)
            self.writer.addFormalParameter("parameters")
            self.writer.beginMethodBody()
            self.writer.add(
                GLC.ReturnStatement(
                    GLC.EqualsExpression(
                                GLC.FunctionCall("sorted", [GLC.FunctionCall("list", [GLC.Property(GLC.SelfProperty("active_states"), "queue")])]), 
                                GLC.FunctionCall("sorted", [GLC.ArrayExpression(targets)])
                                )
                )
            )
            
            self.writer.endMethodBody()
            self.writer.endMethod()
            iteration = iteration + 1

    def chooseNextTransition(self):
        self.writer.beginMethod("process_time_transitions")
        self.writer.addFormalParameter("timers")
        self.writer.addFormalParameter("state_name")
        self.writer.beginMethodBody()

        self.writer.addAssignment("iteration", "0")
        self.writer.addAssignment("chosen", "None")
        self.writer.addAssignment("lowest", GLC.MapIndexedExpression("timers", "0"))
        
        self.writer.beginForLoopIterateArray(GLC.ArrayIndexedExpression(
            GLC.SelfProperty("timedTransitions"), "state_name"),"t")
        # self.writer.addAssignment("port", GLC.Property(GLC.Property("t", "trigger"), "port"))
        # self.writer.addAssignment("source", GLC.Property(GLC.Property("t", "source"), "name"))
        # self.writer.beginIf(
        #     GLC.AndExpression(
        #     GLC.EqualsExpression("source", GLC.Property(
        #         GLC.SelfProperty("current_state"), "name")),
        #     GLC.DifferentExpression("port", GLC.String("input")))
        # )
            
        #myTransitions.append((t, timers[iteration]))
        self.writer.beginIf(
            GLC.GreaterThanOrEqualExpression("lowest", 
                GLC.MapIndexedExpression("timers", "iteration")))
        self.writer.addAssignment("lowest", 
                GLC.MapIndexedExpression("timers", "iteration"))
        self.writer.addAssignment("chosen", "t")
        self.writer.endIf()
        self.writer.addAssignment("iteration", "iteration + 1")
        #self.writer.endIf()
        self.writer.endForLoopIterateArray()

        # self.writer.beginForLoopIterateArray(GLC.SelfProperty("timedTransitions"),"t")
        # self.writer.addAssignment("port", GLC.Property(GLC.Property("t", "trigger"), "port"))
        # self.writer.addAssignment("source", GLC.Property(GLC.Property("t", "source"), "name"))
        # self.writer.beginIf(
        #     GLC.AndExpression(
        #     GLC.EqualsExpression("source", GLC.Property(
        #         GLC.SelfProperty("current_state"), "name")),
        #     GLC.DifferentExpression("port", GLC.String("input")))
        # )
            
        # #myTransitions.append((t, timers[iteration]))
        # self.writer.beginIf(
        #     GLC.GreaterThanOrEqualExpression("lowest", 
        #         GLC.MapIndexedExpression("timers", "iteration")))
        # self.writer.addAssignment("lowest", 
        #         GLC.MapIndexedExpression("timers", "iteration"))
        # self.writer.addAssignment("chosen", "t")
        # self.writer.endIf()
        # self.writer.addAssignment("iteration", "iteration + 1")
        # self.writer.endIf()
        # self.writer.endForLoopIterateArray()
        
        self.writer.beginIf(GLC.GreaterThanExpression("iteration", "0"))
        #self.writer.add(GLC.FunctionCall("print", ["chosen"]))
        transition = GLC.NewExpression("Transition", 
                                    [GLC.SelfExpression(), GLC.Property("chosen", "source"), GLC.Property("chosen", "targets")])
        self.writer.addAssignment("temp", transition)
        event = GLC.NewExpression("Event", 
                                [GLC.String("step"), GLC.FunctionCall(GLC.SelfProperty("getInPortName"), [GLC.String("input")])])
        self.writer.add(GLC.FunctionCall(GLC.Property("temp", "setTrigger"), [event]))
        self.writer.add(GLC.FunctionCall(GLC.Property("temp", "setAction"), [GLC.Property("chosen", "action")]))
        self.writer.add(GLC.FunctionCall(GLC.Property("temp", "setGuard"), [GLC.Property("chosen", "guard")]))
        
        #self.writer.add(GLC.FunctionCall(GLC.Property("chosen", GLC.Property("source", "addTransition")), ["temp"]))
        
        mapExp = GLC.MapIndexedExpression(
                    GLC.SelfProperty("createdTransitions"),
                    "state_name"
                )

        self.writer.beginIf(
            GLC.NotExpression(
                GLC.FunctionCall(
                    GLC.SelfProperty("listContains"),
                    [mapExp, "temp"])
            ))
        #self.writer.addRawCode("chosen.source.addTransition(temp)")
        
        self.writer.add(GLC.FunctionCall(GLC.Property(mapExp, "append"),["temp"]))
        self.writer.add(GLC.FunctionCall(GLC.Property(GLC.Property("chosen", "source"), "addTransition"),["temp"]))
        self.writer.endIf()
        #friendly_name
        self.writer.addRawCode("attrs = [s.name for s in chosen.targets]")
        #self.writer.addRawCode('print("[time-based] type step to move to {} ".format(attrs))')
        # GLC.AdditionExpression(
        #                                 GLC.AdditionExpression(
        #                                     GLC.Property(
        #                                         GLC.Property("colors", "fg"), "green"),
        #                                         GLC.String("Available Transition Options:")), 
        #                                         GLC.Property("colors", "reset"))
        self.writer.addRawCode("guard = ((inspect.getsourcelines(chosen.guard)[0][1].split('return')[1]).lstrip())[:-1] if chosen.guard != None else chosen.guard")

        self.writer.addRawCode('print((colors.fg.lightgreen + "[time-based]" + colors.fg.lightgrey +" type " + colors.fg.pink +"step" + colors.fg.lightgrey + " to skip the transition to "+ colors.fg.cyan +"{}" + colors.fg.lightgrey +" which has a duration of " + colors.fg.pink + "{}" + colors.fg.lightgrey +" seconds and the guard condition " + colors.fg.pink + "{}" + colors.reset).format(attrs, lowest, guard))')

        self.writer.endIf()

        self.writer.endMethodBody()
        self.writer.endMethod()
            
    def chooseNextInputEvent(self):
        self.writer.beginMethod("process_event_transitions")
        self.writer.addFormalParameter("state_name")
        self.writer.beginMethodBody()
    
        self.writer.addAssignment("possibleT", GLC.MapIndexedExpression(GLC.SelfProperty("eventTransitions"), "state_name",))
        #self.writer.addAssignment("source", GLC.SelfProperty("current_state"))
        #self.writer.addAssignment("i", "0")
        
        self.writer.beginForLoopIterateArray("possibleT", "t")
        
        # transition = GLC.NewExpression("Transition", [GLC.SelfExpression(), "source", GLC.Property("t", "targets")])
        # self.writer.addAssignment("temp", transition)
        # self.writer.addAssignment("name", GLC.AdditionExpression(GLC.String("step"), GLC.FunctionCall("str", ["i"])))
        # #self.writer.addRawCode('name = "step" + str(i)')
        # event = GLC.NewExpression("Event", 
        #                         ["name", GLC.FunctionCall(GLC.SelfProperty("getInPortName"), [GLC.String("input")])])
        # self.writer.add(GLC.FunctionCall(GLC.Property("temp", "setTrigger"), [event]))

        # mapExp = GLC.MapIndexedExpression(
        #             GLC.SelfProperty("createdTransitions"),
        #             "state_name"
        #         )

        # self.writer.beginIf(
        #     GLC.NotExpression(
        #         GLC.FunctionCall(
        #             GLC.SelfProperty("listContains"),
        #             [mapExp, "temp"])
        #     ))

        # self.writer.add(GLC.FunctionCall(GLC.Property(mapExp, "append"),["temp"]))
        # self.writer.add(GLC.FunctionCall(GLC.Property("source","addTransition"), ["temp"]))
        # self.writer.endIf()

        #friendly_name
        self.writer.addRawCode("attrs = [s.name for s in t.targets]")
        self.writer.addRawCode("guard = ((inspect.getsourcelines(t.guard)[0][1].split('return')[1]).lstrip())[:-1] if t.guard != None else t.guard")
        #self.writer.addRawCode('print("[event-based] type {} to move to {} ".format(name, attrs))')

        self.writer.addRawCode('print((colors.fg.lightgreen + "[event-based]"  + colors.fg.lightgrey +" type " + colors.fg.pink +"{}"+ colors.fg.lightgrey + " to perform the transition to "+ colors.fg.cyan + "{}" + colors.fg.lightgrey + " with the guard condition " + colors.fg.pink + "{}"+ colors.reset).format(t.trigger.name, attrs, guard))')
        # self.writer.addAssignment("i", GLC.AdditionExpression("i", "1"))
        self.writer.endForLoopIterateArray()

        self.writer.endMethodBody()
        self.writer.endMethod()
    
    def handleBreakpoints(self, parent_node, timerIndexBase):
        stateName = parent_node.new_full_name
    
        #timerIndex = timerIndex + len(self.breakpoints['states'])
        timerIndex = timerIndexBase # +1?
        for k,v in self.breakpoints['variables'].items():
            varName = k
            valueThreshold = v
            self.writer.beginIf(
                GLC.EqualsExpression(
                    GLC.SelfProperty(varName),
                    valueThreshold
                ))
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"),
                [str(timerIndex), str(0)]))
            self.writer.endIf()
            timerIndex = timerIndex + 1

        if stateName in self.breakpoints['states']:
            stateIndex = self.breakpoints['states'][stateName]
            timerIndex = timerIndex + stateIndex
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"),
                [str(timerIndex), str(0)]))

    def handleTimeBreakpoints(self, timerIndex):
        for v in self.breakpoints['timestamps']:
            timestamp = v
            self.writer.beginIf(
                GLC.NotExpression(
                    GLC.MapIndexedExpression(
                        GLC.SelfProperty("expiredTimestamps"),
                        str(timerIndex - self.numberOfAfterEvents)
                    )))
            self.writer.add(GLC.FunctionCall(GLC.SelfProperty("addTimer"),
                [str(timerIndex), 
                 GLC.MinusExpression(
                     timestamp,
                     GLC.DivisionExpression(
                         GLC.SelfProperty("executionTime"),
                         str(float(1000)) 
                     ))
                     ]))
            self.writer.endIf()
            timerIndex = timerIndex + 1

        return timerIndex

    def printInternalState(self):
        self.writer.beginMethod("print_internal_state")
        self.writer.addFormalParameter("state_name")
        self.writer.beginMethodBody()
        self.writer.add(GLC.FunctionCall("print", [
            GLC.AdditionExpression(GLC.String('\\n'),
                GLC.AdditionExpression(                       
                    GLC.AdditionExpression(GLC.Property(GLC.Property("colors", "fg"), "lightgrey"), GLC.String("Entered ")),
                    GLC.AdditionExpression(
                        GLC.Property(GLC.Property("colors", "fg"), "cyan") ,
                        "state_name")))]))
        
        #  self.writer.add(GLC.FunctionCall("print", [
        #     GLC.AdditionExpression(
        #         GLC.Property(
        #             GLC.Property("colors", "fg"), "cyan") ,"state_name")]))
        for a in self.attributes:
            # self.writer.add(GLC.FunctionCall("print", [
            #         GLC.AdditionExpression(
            #             GLC.String(a.name), GLC.String(": ")
            #         ), 
            #         GLC.SelfProperty(a.name)
            # ]))
            self.writer.add(
                GLC.FunctionCall("print", [
                    GLC.AdditionExpression(
                    GLC.Property(
                        GLC.Property("colors", "fg"), "cyan"),
                    GLC.FunctionCall(
                        GLC.Property(
                            GLC.AdditionExpression(
                            GLC.String(a.name), GLC.AdditionExpression(
                                GLC.String(": {}"), GLC.Property("colors", "reset"))
                        ), "format"), [GLC.SelfProperty(a.name)]
                    ))
                ]))

        self.writer.endMethodBody()
        self.writer.endMethod()

    def printPrompt(self):
        self.writer.beginMethod("print_prompt")
        self.writer.beginMethodBody()

        self.writer.addRawCode('print(colors.fg.lightgrey +"["),')
        self.writer.addAssignment("size", GLC.FunctionCall("len", [GLC.Property(GLC.SelfProperty("active_states"), "queue")]))
        self.writer.addAssignment("iteration", "0")
        self.writer.beginForLoopIterateArray(GLC.FunctionCall("list", [GLC.Property(GLC.SelfProperty("active_states"), "queue")]), "s")
        self.writer.addRawCode('print(s.name),')
        self.writer.beginIf(GLC.LessThanExpression("iteration", GLC.MinusExpression("size", "1")))
        self.writer.addRawCode('print(", "),')
        self.writer.endIf()
        self.writer.addAssignment("iteration", GLC.AdditionExpression("iteration", "1"))
        self.writer.endForLoopIterateArray()
        self.writer.addRawCode('print("] > "+colors.reset),')

        self.writer.endMethodBody()
        self.writer.endMethod()
        #self.writer.addRawCode('print(colors.fg.lightgrey +"['+ state +'] > "+colors.reset),')

    def createTracingEvent(self):
        self.writer.addAssignment("allAttTuples", GLC.ArrayExpression())
        for a in self.attributes:
            self.writer.add(
                GLC.FunctionCall(
                    GLC.Property("allAttTuples", "append"), 
                    [GLC.ArrayExpression([GLC.String(a.name), GLC.SelfProperty(a.name)])]))

        self.writer.add(
            GLC.FunctionCall(
                GLC.SelfProperty("saveEvent"),
                ["event", 
                    GLC.FunctionCall(
                        GLC.SelfProperty("getSimulatedTime")),
                    "allAttTuples"]))